/// <binding ProjectOpened='watch' />
var gulp = require("gulp"),
	gutil = require("gulp-util"),
	webpack = require("webpack"),
	htmlmin = require("gulp-htmlmin"),
	shell = require("gulp-shell"),
	livereload = require("gulp-livereload"),
	rimraf = require("gulp-rimraf"),
	runsequence = require("run-sequence"),
	webpackStream = require("webpack-stream");

var helper = {
	tasks: {
		clear: "clear",
		watch: "watch",
		compile: {
			html: "compile:html",
			ts: "compile:ts",
			deploy: "compile:deploy",
			dnx: {
			    ts: "run:dnx:ts",
			    csharp: "run:dnx:csharp",
			}
		}
	},
	path: {
		source: {
			defaultFile: "./App/App.Component.ts",
			html: "./App/**/*.html"
		},
		destination: {
			html: "./wwwroot/html",
			assets: "./wwwroot/assets"
		},
		entity: "../Sample.Business.Entity/**/*.cs",
		resource: "../Sample.Business.Resource/**/*.resx"
	},
	htmlMimify: {
		collapseWhitespace: true,
		removeComments: true,
		removeTagWhitespace: false,
		removeRedundantAttributes: true,
		caseSensitive: true
	},
	webpack: {
		debug: false,
		watch: false,
		parse: function () {
			var result = require("./webpack.config.js");

			if (helper.webpack.debug === true) {
				result.devtool = "source-map";
				result.watch = helper.webpack.watch;
				result.plugins = result.plugins || [];
				result.plugins.push(helper.webpack.log);
			}

			if (helper.webpack.debug === false) {
				result.debug = false;
				result.plugins = result.plugins || [];
				result.plugins.push(new webpack.NoErrorsPlugin());
				result.plugins.push(new webpack.optimize.DedupePlugin());
				result.plugins.push(new webpack.optimize.UglifyJsPlugin({
					beautify: false,
					comments: false,
					minimize: true,
					mangle: {
						screw_ie8: true,
						keep_fnames: true
					},
					compress: {
						warnings: false,
						screw_ie8: true,
						drop_console: true,
						drop_debugger: true
					}
				}));
			}

			return result;
		},
		log: function () {
			this.plugin("done", function (stats) {
				if (stats.compilation.errors && stats.compilation.errors.length) {
					console.log("");
					console.log("********************************************************************************");
					console.log("********************************   ERROR   *************************************");
					console.log("");
					console.log(stats.compilation.errors);
					console.log("********************************************************************************");
					console.log("");
					stats.compilation.errors = [];
				}
			});
		}
	}
};

gulp.task(helper.tasks.clear, function () {

	return gulp.src([helper.path.destination.html, helper.path.destination.assets], { read: false })
		.pipe(rimraf());

});

gulp.task(helper.tasks.compile.html, function (done) {

	return gulp.src([helper.path.source.html])
        .pipe(htmlmin(helper.htmlMimify))
        .pipe(gulp.dest(helper.path.destination.html))
		.on("end", function () {
			livereload.reload("index.html");
		});

});

gulp.task(helper.tasks.compile.ts, function () {

	return gulp.src(helper.path.source.defaultFile)
        .pipe(webpackStream(helper.webpack.parse()))
        .pipe(gulp.dest(helper.path.destination.assets))
        .pipe(livereload());

});

gulp.task(helper.tasks.compile.deploy, function () {

	helper.webpack.debug = false;
	helper.webpack.watch = false;

	return runsequence(helper.tasks.clear,
		[helper.tasks.compile.html, helper.tasks.compile.ts]);

});

gulp.task(helper.tasks.watch, function () {

	helper.webpack.debug = true;
	helper.webpack.watch = true;

	livereload.listen();

	var sub = gulp.task(helper.tasks.watch + ":sub", function () {
		gulp.watch([helper.path.source.html], [helper.tasks.compile.html]);
		gulp.watch([helper.path.resource], [helper.tasks.compile.dnx]);
		gulp.watch([helper.path.entity], [helper.tasks.compile.dnx]);
	});

	return runsequence(helper.tasks.clear, helper.tasks.compile.html,
		[helper.tasks.watch + ":sub", helper.tasks.compile.ts]);

});

gulp.task(helper.tasks.compile.dnx.ts, shell.task(["dotnet run --project ../[{codegenerator}]/project.json -- -t"]));
gulp.task(helper.tasks.compile.dnx.csharp, shell.task(["dotnet run --project ../[{codegenerator}]/project.json -- -c"]));